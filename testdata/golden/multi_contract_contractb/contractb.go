// Code generated by solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: ContractB (solc 0.8.20)

package contractb

import (
	"fmt"
	"github.com/ethereum/go-ethereum/common"
)

// Contract metadata
var _abiJSON = "[\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"function\",\n\t\t\t\t\t\"name\": \"functionB\",\n\t\t\t\t\t\"inputs\": [{\"name\": \"param\", \"type\": \"string\"}],\n\t\t\t\t\t\"outputs\": [{\"name\": \"\", \"type\": \"bytes32\"}],\n\t\t\t\t\t\"stateMutability\": \"pure\"  \n\t\t\t\t}\n\t\t\t]"
var _hexBytecode = "0x608060405234801561001057600080fd5b50610789"
var _hexDeployedBytecode = "0x608060405234801561001057600080fd5b50610abc"

// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

// HexBytecode returns the contract creation bytecode
func HexBytecode() string {
	return _hexBytecode
}

// HexDeployedBytecode returns the contract runtime bytecode
func HexDeployedBytecode() string {
	return _hexDeployedBytecode
}

// Method information struct
type MethodInfo struct {
	Name      string
	Signature string
	Selector  string
}

// Event information struct
type EventInfo struct {
	Name  string
	Topic common.Hash
}

// Error information struct
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  string
}

// Constructor information struct
type ConstructorInfo struct {
	Signature string
}

// Constructor returns constructor information
func Constructor() ConstructorInfo {
	return ConstructorInfo{
		Signature: "",
	}
}

// Method information
func FunctionBMethod() MethodInfo {
	return MethodInfo{
		Name:      "functionB",
		Signature: "functionB(string)",
		Selector:  "0xbbbbbbbb",
	}
}

// Event information

// Error information

// Method registry
type MethodRegistry struct {
	FunctionB MethodInfo
}

// Event registry
type EventRegistry struct {
}

// Error registry
type ErrorRegistry struct {
}

// Methods returns all contract method information
func Methods() MethodRegistry {
	return MethodRegistry{
		FunctionB: FunctionBMethod(),
	}
}

// Events returns all contract event information
func Events() EventRegistry {
	return EventRegistry{}
}

// Errors returns all contract error information
func Errors() ErrorRegistry {
	return ErrorRegistry{}
}

// Simple utility functions for basic contract interaction without external dependencies

// HexToBytes converts a hex string to bytes
func HexToBytes(s string) ([]byte, error) {
	if len(s) >= 2 && s[0:2] == "0x" {
		s = s[2:]
	}
	if len(s)%2 == 1 {
		s = "0" + s
	}
	result := make([]byte, len(s)/2)
	for i := 0; i < len(s); i += 2 {
		high := hexCharToByte(s[i])
		low := hexCharToByte(s[i+1])
		if high == 255 || low == 255 {
			return nil, fmt.Errorf("invalid hex character")
		}
		result[i/2] = high<<4 | low
	}
	return result, nil
}

// MustHexToBytes converts a hex string to bytes, panics on error
func MustHexToBytes(s string) []byte {
	result, err := HexToBytes(s)
	if err != nil {
		panic(err)
	}
	return result
}

// BytesToHex converts bytes to hex string
func BytesToHex(data []byte) string {
	const hexChars = "0123456789abcdef"
	result := make([]byte, len(data)*2+2)
	result[0] = '0'
	result[1] = 'x'
	for i, b := range data {
		result[i*2+2] = hexChars[b>>4]
		result[i*2+3] = hexChars[b&0x0f]
	}
	return string(result)
}

func hexCharToByte(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	default:
		return 255 // Invalid
	}
}

// MethodID calculates the method ID from a method signature
func MethodID(signature string) [4]byte {
	hash := keccak256([]byte(signature))
	var methodID [4]byte
	copy(methodID[:], hash[:4])
	return methodID
}

// EventTopic calculates the event topic hash from an event signature
func EventTopic(signature string) [32]byte {
	return keccak256([]byte(signature))
}

// Simple Keccak-256 implementation
func keccak256(data []byte) [32]byte {
	// This is a simplified placeholder - in production you'd want a proper keccak256 implementation
	// For now, we'll use a simple hash that produces consistent results
	var result [32]byte
	for i, b := range data {
		result[i%32] ^= b
	}
	// Simple mixing to distribute bits
	for i := 0; i < 32; i++ {
		result[i] = result[i]<<1 ^ result[(i+1)%32]>>1 ^ result[(i+7)%32]
	}
	return result
}

// PackMethodCall creates method call data with method ID and encoded parameters
// This is a simplified version - in production you'd want proper ABI encoding
func PackMethodCall(methodSig string, args ...interface{}) ([]byte, error) {
	methodID := MethodID(methodSig)
	result := make([]byte, 4)
	copy(result, methodID[:])

	// For simple demonstration - in production you'd properly encode parameters
	// This simplified version just handles basic cases
	for _, arg := range args {
		switch v := arg.(type) {
		case string:
			// Simple string encoding (not ABI compliant, but functional)
			data := []byte(v)
			result = append(result, data...)
		case []byte:
			result = append(result, v...)
		default:
			return nil, fmt.Errorf("unsupported argument type: %T", v)
		}
	}

	return result, nil
}
