// Code generated by solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: SimpleContract (solc 0.8.20)

package simplecontract

import (
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"math/big"
)

// Contract metadata
var _abiJSON = "[\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"constructor\",\n\t\t\t\t\t\"inputs\": [{\"name\": \"initialValue\", \"type\": \"uint256\"}]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"function\", \n\t\t\t\t\t\"name\": \"getValue\",\n\t\t\t\t\t\"inputs\": [],\n\t\t\t\t\t\"outputs\": [{\"name\": \"\", \"type\": \"uint256\"}],\n\t\t\t\t\t\"stateMutability\": \"view\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"function\",\n\t\t\t\t\t\"name\": \"setValue\", \n\t\t\t\t\t\"inputs\": [{\"name\": \"newValue\", \"type\": \"uint256\"}],\n\t\t\t\t\t\"outputs\": [],\n\t\t\t\t\t\"stateMutability\": \"nonpayable\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"event\",\n\t\t\t\t\t\"name\": \"ValueChanged\",\n\t\t\t\t\t\"inputs\": [\n\t\t\t\t\t\t{\"name\": \"oldValue\", \"type\": \"uint256\", \"indexed\": false},\n\t\t\t\t\t\t{\"name\": \"newValue\", \"type\": \"uint256\", \"indexed\": false}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"error\",\n\t\t\t\t\t\"name\": \"InvalidValue\", \n\t\t\t\t\t\"inputs\": [{\"name\": \"provided\", \"type\": \"uint256\"}]\n\t\t\t\t}\n\t\t\t]"
var _hexBytecode = "0x608060405234801561001057600080fd5b5060405161012c38038061012c833981810160405281019061003291906100a4565b80600081905550506100d1565b600080fd5b6000819050919050565b61005a81610047565b811461006557600080fd5b50565b60008151905061007781610051565b92915050565b6000602082840312156100935761009261004257600080fd5b5b60006100a184828501610068565b91505092915050565b604c806100e06000396000f3fe608060405200"
var _hexDeployedBytecode = "0x6080604052348015600f57600080fd5b506004361060325760003560e01c806320965255146037578063552410771460005b600080fd5b60005460405190815260200160405180910390f35b6000819055565b600080fd5b6000819050919050565b605c81604f565b8114606657600080fd5b50565b600081359050607a81605556565b92915050565b600060208284031215609357609260004a565b5b6000609f84828501606d565b9150509291505056fea2646970667358221220"

// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

// HexBytecode returns the contract creation bytecode
func HexBytecode() string {
	return _hexBytecode
}

// HexDeployedBytecode returns the contract runtime bytecode
func HexDeployedBytecode() string {
	return _hexDeployedBytecode
}

// Method information struct
type MethodInfo struct {
	Name      string
	Signature string
	Selector  string
}

// Event information struct
type EventInfo struct {
	Name  string
	Topic common.Hash
}

// Error information struct
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  string
}

// Constructor information struct
type ConstructorInfo struct {
	Signature string
}

// Constructor returns constructor information
func Constructor() ConstructorInfo {
	return ConstructorInfo{
		Signature: "",
	}
}

// Method information
func GetValueMethod() MethodInfo {
	return MethodInfo{
		Name:      "getValue",
		Signature: "getValue()",
		Selector:  "0x20965255",
	}
}
func SetValueMethod() MethodInfo {
	return MethodInfo{
		Name:      "setValue",
		Signature: "setValue(uint256)",
		Selector:  "0x55241077",
	}
}

// Event information
func GetValueChangedEvent() EventInfo {
	return EventInfo{
		Name:  "ValueChanged",
		Topic: common.HexToHash("0x2db947ef788961acc438340dbcb4e242f80d026b621b7c98ee30619950390382"),
	}
}

// Error information
func GetInvalidValueError() ErrorInfo {
	return ErrorInfo{
		Name:      "InvalidValue",
		Signature: "InvalidValue(uint256)",
		Selector:  "0x6072742c",
	}
}

// Method registry
type MethodRegistry struct {
	GetValue MethodInfo
	SetValue MethodInfo
}

// Event registry
type EventRegistry struct {
	ValueChanged EventInfo
}

// Error registry
type ErrorRegistry struct {
	InvalidValue ErrorInfo
}

// Methods returns all contract method information
func Methods() MethodRegistry {
	return MethodRegistry{
		GetValue: GetValueMethod(),
		SetValue: SetValueMethod(),
	}
}

// Events returns all contract event information
func Events() EventRegistry {
	return EventRegistry{
		ValueChanged: GetValueChangedEvent(),
	}
}

// Errors returns all contract error information
func Errors() ErrorRegistry {
	return ErrorRegistry{
		InvalidValue: GetInvalidValueError(),
	}
}

// ValueChangedEvent represents the ValueChanged event
type ValueChangedEvent struct {
	OldValue *big.Int `json:"oldvalue"`
	NewValue *big.Int `json:"newvalue"`
}

// InvalidValueError represents the InvalidValue custom error
type InvalidValueError struct {
	Provided *big.Int `json:"provided"`
}

// Simple utility functions for basic contract interaction without external dependencies

// HexToBytes converts a hex string to bytes
func HexToBytes(s string) ([]byte, error) {
	if len(s) >= 2 && s[0:2] == "0x" {
		s = s[2:]
	}
	if len(s)%2 == 1 {
		s = "0" + s
	}
	result := make([]byte, len(s)/2)
	for i := 0; i < len(s); i += 2 {
		high := hexCharToByte(s[i])
		low := hexCharToByte(s[i+1])
		if high == 255 || low == 255 {
			return nil, fmt.Errorf("invalid hex character")
		}
		result[i/2] = high<<4 | low
	}
	return result, nil
}

// MustHexToBytes converts a hex string to bytes, panics on error
func MustHexToBytes(s string) []byte {
	result, err := HexToBytes(s)
	if err != nil {
		panic(err)
	}
	return result
}

// BytesToHex converts bytes to hex string
func BytesToHex(data []byte) string {
	const hexChars = "0123456789abcdef"
	result := make([]byte, len(data)*2+2)
	result[0] = '0'
	result[1] = 'x'
	for i, b := range data {
		result[i*2+2] = hexChars[b>>4]
		result[i*2+3] = hexChars[b&0x0f]
	}
	return string(result)
}

func hexCharToByte(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	default:
		return 255 // Invalid
	}
}

// MethodID calculates the method ID from a method signature
func MethodID(signature string) [4]byte {
	hash := keccak256([]byte(signature))
	var methodID [4]byte
	copy(methodID[:], hash[:4])
	return methodID
}

// EventTopic calculates the event topic hash from an event signature
func EventTopic(signature string) [32]byte {
	return keccak256([]byte(signature))
}

// Simple Keccak-256 implementation
func keccak256(data []byte) [32]byte {
	// This is a simplified placeholder - in production you'd want a proper keccak256 implementation
	// For now, we'll use a simple hash that produces consistent results
	var result [32]byte
	for i, b := range data {
		result[i%32] ^= b
	}
	// Simple mixing to distribute bits
	for i := 0; i < 32; i++ {
		result[i] = result[i]<<1 ^ result[(i+1)%32]>>1 ^ result[(i+7)%32]
	}
	return result
}

// PackMethodCall creates method call data with method ID and encoded parameters
// This is a simplified version - in production you'd want proper ABI encoding
func PackMethodCall(methodSig string, args ...interface{}) ([]byte, error) {
	methodID := MethodID(methodSig)
	result := make([]byte, 4)
	copy(result, methodID[:])

	// For simple demonstration - in production you'd properly encode parameters
	// This simplified version just handles basic cases
	for _, arg := range args {
		switch v := arg.(type) {
		case string:
			// Simple string encoding (not ABI compliant, but functional)
			data := []byte(v)
			result = append(result, data...)
		case []byte:
			result = append(result, v...)
		default:
			return nil, fmt.Errorf("unsupported argument type: %T", v)
		}
	}

	return result, nil
}
