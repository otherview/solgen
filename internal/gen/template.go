// SPDX-License-Identifier: MIT

package gen

// contractTemplate is the main template for generating contract Go packages
const contractTemplate = `// Code generated by github.com/otherview/solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: {{.Contract.Name}} (solc {{.Contract.SolcVersion | default "unknown"}})

package {{.Contract.PackageName}}

import (
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"strings"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// Contract metadata
var _abiJSON = {{.Contract.ABIJson | quote}}


// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

// Address represents a 20-byte Ethereum address
type Address [20]byte

// String returns the hex string representation of the address
func (a Address) String() string {
	return "0x" + hex.EncodeToString(a[:])
}

// Hash represents a 32-byte hash
type Hash [32]byte

// String returns the hex string representation of the hash
func (h Hash) String() string {
	return "0x" + hex.EncodeToString(h[:])
}

// Bytes returns the hash as a byte slice
func (h Hash) Bytes() []byte {
	return h[:]
}

// AddressFromHex creates an Address from a hex string
func AddressFromHex(s string) Address {
	var addr Address
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 40 {
		panic("invalid address hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid address hex string: " + err.Error())
	}
	copy(addr[:], decoded)
	return addr
}

// HashFromHex creates a Hash from a hex string
func HashFromHex(s string) Hash {
	var hash Hash
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 64 {
		panic("invalid hash hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hash hex string: " + err.Error())
	}
	copy(hash[:], decoded)
	return hash
}

// HexData provides convenient access to hex-encoded byte data
type HexData string

// Hex returns the hex string representation
func (h HexData) Hex() string {
	return string(h)
}

// Bytes returns the decoded bytes from the hex string
func (h HexData) Bytes() []byte {
	hexStr := string(h)
	if hexStr == "" {
		return nil
	}
	
	// Remove 0x prefix if present
	if len(hexStr) >= 2 && hexStr[:2] == "0x" {
		hexStr = hexStr[2:]
	}
	
	if hexStr == "" {
		return nil
	}
	
	data, err := hex.DecodeString(hexStr)
	if err != nil {
		panic("invalid hex string in generated code: " + string(h))
	}
	return data
}

// ABI Encoding/Decoding Implementation

// encodeUint256 encodes a uint256 value to 32 bytes (big-endian)
func encodeUint256(val interface{}) ([]byte, error) {
	result := make([]byte, 32)
	switch v := val.(type) {
	case *big.Int:
		if v.Sign() < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		if v.BitLen() > 256 {
			return nil, errors.New("value too large for uint256")
		}
		v.FillBytes(result)
		return result, nil
	case uint64:
		big.NewInt(0).SetUint64(v).FillBytes(result)
		return result, nil
	case int64:
		if v < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		big.NewInt(v).FillBytes(result)
		return result, nil
	case int:
		if v < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		big.NewInt(int64(v)).FillBytes(result)
		return result, nil
	default:
		return nil, fmt.Errorf("unsupported type for uint256: %T", v)
	}
}

// mustEncodeUint256 encodes a uint256 value, panics on error
func mustEncodeUint256(val interface{}) []byte {
	result, err := encodeUint256(val)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeAddress encodes an address to 32 bytes (left-padded with zeros)
func encodeAddress(addr Address) []byte {
	result := make([]byte, 32)
	copy(result[12:], addr[:])
	return result
}

// encodeBool encodes a boolean to 32 bytes
func encodeBool(val bool) []byte {
	result := make([]byte, 32)
	if val {
		result[31] = 1
	}
	return result
}

// encodeBytes encodes dynamic bytes
func encodeBytes(data []byte) []byte {
	// Length + data + padding
	length := mustEncodeUint256(uint64(len(data)))
	padded := make([]byte, ((len(data)+31)/32)*32) // Pad to multiple of 32
	copy(padded, data)
	return append(length, padded...)
}

// encodeInt256 encodes a signed 256-bit integer to 32 bytes (two's complement)
func encodeInt256(val interface{}) ([]byte, error) {
	result := make([]byte, 32)
	switch v := val.(type) {
	case *big.Int:
		if v.BitLen() > 255 { // 255 bits for magnitude + 1 for sign
			return nil, errors.New("value too large for int256")
		}
		if v.Sign() >= 0 {
			v.FillBytes(result)
		} else {
			// Two's complement for negative numbers
			pos := new(big.Int).Abs(v)
			pos.FillBytes(result)
			// Flip bits
			for i := range result {
				result[i] = ^result[i]
			}
			// Add 1
			carry := byte(1)
			for i := 31; i >= 0 && carry > 0; i-- {
				sum := int(result[i]) + int(carry)
				result[i] = byte(sum)
				carry = byte(sum >> 8)
			}
		}
		return result, nil
	case int64:
		big.NewInt(v).FillBytes(result)
		if v < 0 {
			return encodeInt256(big.NewInt(v))
		}
		return result, nil
	case int:
		return encodeInt256(int64(v))
	default:
		return nil, fmt.Errorf("unsupported type for int256: %T", v)
	}
}

// mustEncodeInt256 encodes a signed 256-bit integer, panics on error
func mustEncodeInt256(val interface{}) []byte {
	result, err := encodeInt256(val)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeFixedBytes encodes fixed-size bytes (e.g., bytes32)
func encodeFixedBytes(data []byte, size int) []byte {
	if len(data) > size {
		panic(fmt.Sprintf("data too large for bytes%d: got %d bytes", size, len(data)))
	}
	result := make([]byte, 32)
	copy(result[:len(data)], data)
	return result
}

// encodeArray encodes dynamic or fixed arrays
func encodeArray(elements []interface{}) ([]byte, error) {
	if len(elements) == 0 {
		return mustEncodeUint256(uint64(0)), nil
	}
	
	// For dynamic arrays, start with length
	result := mustEncodeUint256(uint64(len(elements)))
	
	// Encode each element
	for _, elem := range elements {
		switch v := elem.(type) {
		case *big.Int:
			data, err := encodeUint256(v)
			if err != nil {
				return nil, fmt.Errorf("encoding array element: %w", err)
			}
			result = append(result, data...)
		case uint64:
			result = append(result, mustEncodeUint256(v)...)
		case Address:
			result = append(result, encodeAddress(v)...)
		case bool:
			result = append(result, encodeBool(v)...)
		default:
			return nil, fmt.Errorf("unsupported array element type: %T", v)
		}
	}
	
	return result, nil
}

// mustEncodeArray encodes an array, panics on error
func mustEncodeArray(elements []interface{}) []byte {
	result, err := encodeArray(elements)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeString encodes a string as dynamic bytes
func encodeString(str string) []byte {
	return encodeBytes([]byte(str))
}

// decodeUint256 decodes a uint256 from 32 bytes to *big.Int
func decodeUint256(data []byte) (*big.Int, error) {
	if len(data) < 32 {
		return nil, errors.New("insufficient data for uint256")
	}
	return new(big.Int).SetBytes(data[:32]), nil
}

// mustDecodeUint256 decodes a uint256, panics on error
func mustDecodeUint256(data []byte) *big.Int {
	result, err := decodeUint256(data)
	if err != nil {
		panic(err)
	}
	return result
}

// decodeInt256 decodes a signed 256-bit integer from 32 bytes
func decodeInt256(data []byte) (*big.Int, error) {
	if len(data) < 32 {
		return nil, errors.New("insufficient data for int256")
	}
	
	result := new(big.Int).SetBytes(data[:32])
	
	// Check if negative (MSB is set)
	if data[0]&0x80 != 0 {
		// Convert from two's complement
		// Create mask with all bits set for 256-bit number
		mask := new(big.Int).Lsh(big.NewInt(1), 256)
		mask.Sub(mask, big.NewInt(1))
		
		// XOR with mask and add 1 to get absolute value
		result.Xor(result, mask)
		result.Add(result, big.NewInt(1))
		result.Neg(result)
	}
	
	return result, nil
}

// mustDecodeInt256 decodes a signed 256-bit integer, panics on error
func mustDecodeInt256(data []byte) *big.Int {
	result, err := decodeInt256(data)
	if err != nil {
		panic(err)
	}
	return result
}

// decodeAddress decodes an address from 32 bytes
func decodeAddress(data []byte) Address {
	if len(data) < 32 {
		panic("insufficient data for address")
	}
	var addr Address
	copy(addr[:], data[12:32])
	return addr
}

// decodeBool decodes a boolean from 32 bytes
func decodeBool(data []byte) bool {
	if len(data) < 32 {
		panic("insufficient data for bool")
	}
	return data[31] != 0
}

// decodeBytes decodes dynamic bytes
func decodeBytes(data []byte, offset int) ([]byte, int) {
	if len(data) < offset+32 {
		panic("insufficient data for bytes length")
	}
	lengthBig := mustDecodeUint256(data[offset : offset+32])
	if !lengthBig.IsUint64() {
		panic("bytes length too large")
	}
	length := int(lengthBig.Uint64())
	if len(data) < offset+32+length {
		panic("insufficient data for bytes content")
	}
	result := make([]byte, length)
	copy(result, data[offset+32:offset+32+length])
	// Calculate next offset (padded to 32 bytes)
	paddedLength := ((length + 31) / 32) * 32
	return result, offset + 32 + paddedLength
}

// decodeFixedBytes decodes fixed-size bytes (e.g., bytes32)
func decodeFixedBytes(data []byte, size int) []byte {
	if len(data) < 32 {
		panic("insufficient data for fixed bytes")
	}
	if size > 32 {
		panic("fixed bytes size too large")
	}
	result := make([]byte, size)
	copy(result, data[:size])
	return result
}

// decode various fixed-size byte arrays
func decodeBytes1(data []byte) [1]byte {
	var result [1]byte
	copy(result[:], decodeFixedBytes(data, 1))
	return result
}

func decodeBytes32(data []byte) [32]byte {
	var result [32]byte
	copy(result[:], decodeFixedBytes(data, 32))
	return result
}

// decodeArray decodes dynamic arrays 
func decodeArray(data []byte, offset int, elemDecoder func([]byte) interface{}) ([]interface{}, int) {
	if len(data) < offset+32 {
		panic("insufficient data for array length")
	}
	
	lengthBig := mustDecodeUint256(data[offset : offset+32])
	if !lengthBig.IsUint64() {
		panic("array length too large")
	}
	length := int(lengthBig.Uint64())
	
	currentOffset := offset + 32
	result := make([]interface{}, length)
	
	for i := 0; i < length; i++ {
		if len(data) < currentOffset+32 {
			panic(fmt.Sprintf("insufficient data for array element %d", i))
		}
		result[i] = elemDecoder(data[currentOffset : currentOffset+32])
		currentOffset += 32
	}
	
	return result, currentOffset
}

// Array element decoders (internal use)
func decodeUint256ArrayElement(data []byte) interface{} {
	return mustDecodeUint256(data)
}

func decodeAddressArrayElement(data []byte) interface{} {
	return decodeAddress(data)
}

func decodeBoolArrayElement(data []byte) interface{} {
	return decodeBool(data)
}

// decodeUint8 decodes a uint8 from 32 bytes
func decodeUint8(data []byte) uint8 {
	if len(data) < 32 {
		panic("insufficient data for uint8")
	}
	// Verify upper bytes are zero
	for i := 0; i < 31; i++ {
		if data[i] != 0 {
			panic("invalid uint8 encoding")
		}
	}
	return data[31]
}

// decodeUint16 decodes a uint16 from 32 bytes
func decodeUint16(data []byte) uint16 {
	if len(data) < 32 {
		panic("insufficient data for uint16")
	}
	// Verify upper bytes are zero
	for i := 0; i < 30; i++ {
		if data[i] != 0 {
			panic("invalid uint16 encoding")
		}
	}
	return uint16(data[30])<<8 | uint16(data[31])
}

// decodeUint32 decodes a uint32 from 32 bytes
func decodeUint32(data []byte) uint32 {
	if len(data) < 32 {
		panic("insufficient data for uint32")
	}
	// Verify upper bytes are zero
	for i := 0; i < 28; i++ {
		if data[i] != 0 {
			panic("invalid uint32 encoding")
		}
	}
	var result uint32
	for i := 28; i < 32; i++ {
		result = (result << 8) | uint32(data[i])
	}
	return result
}

// decodeUint64 decodes a uint64 from 32 bytes  
func decodeUint64(data []byte) uint64 {
	if len(data) < 32 {
		panic("insufficient data for uint64")
	}
	// Check if value exceeds uint64 range
	for i := 0; i < 24; i++ {
		if data[i] != 0 {
			panic("value exceeds uint64 range")
		}
	}
	var result uint64
	for i := 24; i < 32; i++ {
		result = (result << 8) | uint64(data[i])
	}
	return result
}

// decodeInt64 decodes a int64 from 32 bytes
func decodeInt64(data []byte) int64 {
	if len(data) < 32 {
		panic("insufficient data for int64")
	}
	
	// Check if this is a negative number (MSB set)
	isNegative := data[0]&0x80 != 0
	
	// Verify upper bytes are consistent (all 0s or all 1s for sign extension)
	expectedByte := byte(0)
	if isNegative {
		expectedByte = 0xFF
	}
	
	for i := 0; i < 24; i++ {
		if data[i] != expectedByte {
			panic("value exceeds int64 range")
		}
	}
	
	var result int64
	for i := 24; i < 32; i++ {
		result = (result << 8) | int64(data[i])
	}
	
	// Sign extend if necessary
	if isNegative {
		result |= ^((1 << 32) - 1) // Set upper 32 bits
	}
	
	return result
}

// decodeHash decodes a 32-byte hash
func decodeHash(data []byte) Hash {
	if len(data) < 32 {
		panic("insufficient data for hash")
	}
	var hash Hash
	copy(hash[:], data[:32])
	return hash
}

// decodeString decodes a string from dynamic bytes
func decodeString(data []byte, offset int) (string, int) {
	bytes, nextOffset := decodeBytes(data, offset)
	return string(bytes), nextOffset
}

{{- if and .Contract.Bytecode (ne .Contract.Bytecode.Hex "0x") (ne .Contract.Bytecode.Hex "")}}
// Bytecode contains the contract creation bytecode
var Bytecode = HexData({{.Contract.Bytecode.Hex | quote}})
{{- end}}

{{- if and .Contract.DeployedBytecode (ne .Contract.DeployedBytecode.Hex "0x") (ne .Contract.DeployedBytecode.Hex "")}}
// DeployedBytecode contains the contract runtime bytecode  
var DeployedBytecode = HexData({{.Contract.DeployedBytecode.Hex | quote}})
{{- end}}

// Method information struct
type MethodInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// Event information struct
type EventInfo struct {
	Name string
	Topic Hash
}

// Error information struct
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// PackableMethod represents a method with packing capabilities
type PackableMethod struct {
	Name      string
	Signature string
	Selector  HexData
}

// PackableEvent represents an event with unpacking capabilities
type PackableEvent struct {
	Name  string
	Topic Hash
}

// PackableError represents an error with unpacking capabilities
type PackableError struct {
	Name      string
	Signature string
	Selector  HexData
}



// Pack encodes method arguments and returns the method selector + encoded arguments
func (pm *PackableMethod) Pack(args ...any) (HexData, error) {
	// Start with the 4-byte method selector
	selectorBytes := pm.Selector.Bytes()
	if len(selectorBytes) == 0 {
		return "", fmt.Errorf("invalid method selector")
	}
	
	// If no arguments, return just the selector
	if len(args) == 0 {
		return pm.Selector, nil
	}
	
	// Encode arguments using our ABI implementation
	var encodedArgs []byte
	for _, arg := range args {
		switch v := arg.(type) {
		case *big.Int:
			data, err := encodeUint256(v)
			if err != nil {
				return "", fmt.Errorf("encoding big.Int: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case Address:
			encodedArgs = append(encodedArgs, encodeAddress(v)...)
		case uint64, uint32, uint16, uint8:
			data, err := encodeUint256(v)
			if err != nil {
				return "", fmt.Errorf("encoding uint: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case int64, int32, int16, int8, int:
			data, err := encodeInt256(v)
			if err != nil {
				return "", fmt.Errorf("encoding int: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case bool:
			encodedArgs = append(encodedArgs, encodeBool(v)...)
		case string:
			encodedArgs = append(encodedArgs, encodeString(v)...)
		case []byte:
			encodedArgs = append(encodedArgs, encodeBytes(v)...)
		case [1]byte:
			encodedArgs = append(encodedArgs, encodeFixedBytes(v[:], 1)...)
		case [32]byte:
			encodedArgs = append(encodedArgs, encodeFixedBytes(v[:], 32)...)
		case []*big.Int:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []*big.Int array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case []uint64:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []uint64 array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case []Address:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []Address array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		default:
			return "", fmt.Errorf("unsupported argument type: %T", v)
		}
	}
	
	// Combine selector + encoded arguments
	result := make([]byte, len(selectorBytes)+len(encodedArgs))
	copy(result, selectorBytes)
	copy(result[len(selectorBytes):], encodedArgs)
	
	return HexData("0x" + hex.EncodeToString(result)), nil
}

// MustPack encodes method arguments and panics on error
func (pm *PackableMethod) MustPack(args ...any) HexData {
	data, err := pm.Pack(args...)
	if err != nil {
		panic(fmt.Sprintf("Pack failed: %v", err))
	}
	return data
}



{{if .Contract.Constructor}}
// Constructor information struct
type ConstructorInfo struct {
	Signature string
}

// Constructor returns constructor information
func Constructor() ConstructorInfo {
	return ConstructorInfo{
		Signature: {{.Contract.Constructor.Signature | quote}},
	}
}
{{end}}


// Event information
{{- range .Contract.Events}}
func Get{{.Name}}Event() EventInfo {
	return EventInfo{
		Name:  {{.Name | quote}},
		Topic: HashFromHex({{printf "0x%x" .Topic.Bytes | quote}}),
	}
}
{{- end}}

// Error information  
{{- range .Contract.Errors}}
func Get{{.Name}}Error() ErrorInfo {
	return ErrorInfo{
		Name:      {{.Name | quote}},
		Signature: {{.Signature | quote}},
		Selector:  HexData({{.Selector.Hex | quote}}),
	}
}
{{- end}}

// Method registry provides access to packable contract methods
type MethodRegistry struct{}

// Event registry provides access to packable contract events
type EventRegistry struct{}

// Error registry provides access to packable contract errors
type ErrorRegistry struct{}

{{- range .Contract.Methods}}
// {{.Name | title}}Method returns a packable method for {{.Name}}
func (mr MethodRegistry) {{.Name | title}}Method() *{{.Name | title}}Method {
	return &{{.Name | title}}Method{
		PackableMethod: PackableMethod{
			Name:      {{.Name | quote}},
			Signature: {{.Signature | quote}},
			Selector:  HexData({{.Selector.Hex | quote}}),
		},
	}
}
{{- end}}

{{- range .Contract.Events}}
// {{.Name}}Event returns a packable event for {{.Name}}
func (er EventRegistry) {{.Name}}Event() *{{.Name}}EventDecoder {
	return &{{.Name}}EventDecoder{
		PackableEvent: PackableEvent{
			Name:  {{.Name | quote}},
			Topic: HashFromHex({{printf "0x%x" .Topic.Bytes | quote}}),
		},
	}
}
{{- end}}

{{- range .Contract.Errors}}
// {{.Name}}Error returns a packable error for {{.Name}}
func (er ErrorRegistry) {{.Name}}Error() *{{.Name}}ErrorDecoder {
	return &{{.Name}}ErrorDecoder{
		PackableError: PackableError{
			Name:      {{.Name | quote}},
			Signature: {{.Signature | quote}},
			Selector:  HexData({{.Selector.Hex | quote}}),
		},
	}
}
{{- end}}

// Methods returns the method registry
func Methods() MethodRegistry {
	return MethodRegistry{}
}

// Events returns the event registry
func Events() EventRegistry {
	return EventRegistry{}
}

// Errors returns the error registry
func Errors() ErrorRegistry {
	return ErrorRegistry{}
}

{{/* Generate event structs */}}
{{- range .Contract.Events}}

// {{.Struct.Name}} represents the {{.Name}} event
type {{.Struct.Name}} struct {
{{- range .Struct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate error structs */}}
{{- range .Contract.Errors}}

// {{.Struct.Name}} represents the {{.Name}} custom error
type {{.Struct.Name}} struct {
{{- range .Struct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate standalone structs */}}
{{- range .Contract.Structs}}

// {{.Name}} represents a Solidity struct
type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate input/output structs for methods */}}
{{- range .Contract.Methods}}
{{- if .InputStruct}}

// {{.InputStruct.Name}} represents inputs for method {{.Name}}
type {{.InputStruct.Name}} struct {
{{- range .InputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{- if .OutputStruct}}

// {{.OutputStruct.Name}} represents outputs for method {{.Name}}
type {{.OutputStruct.Name}} struct {
{{- range .OutputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}
{{- end}}

{{/* Generate constructor struct if needed */}}
{{- if and .Contract.Constructor .Contract.Constructor.InputStruct}}

// {{.Contract.Constructor.InputStruct.Name}} represents constructor inputs
type {{.Contract.Constructor.InputStruct.Name}} struct {
{{- range .Contract.Constructor.InputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate custom result structs for methods with multiple return values */}}
{{- range .Contract.Methods}}
{{- if gt (len .Outputs) 1}}

// {{.Name | title}}Result represents the return values for {{.Name}} method
type {{.Name | title}}Result struct {
{{- range .Outputs}}
	{{.Name | title}} {{formatGoType .Type}} ` + "`" + `json:"{{.Name | lower}}"` + "`" + `
{{- end}}
}
{{- end}}
{{- end}}

{{/* Generate specific method types */}}
{{- range .Contract.Methods}}

// {{.Name | title}}Method represents the {{.Name}} method with type-safe decode functionality
type {{.Name | title}}Method struct {
	PackableMethod
}
{{- end}}

{{/* Generate specific event types */}}
{{- range .Contract.Events}}

// {{.Name}}EventDecoder represents the {{.Name}} event with type-safe decode functionality
type {{.Name}}EventDecoder struct {
	PackableEvent
}
{{- end}}

{{/* Generate specific error types */}}
{{- range .Contract.Errors}}

// {{.Name}}ErrorDecoder represents the {{.Name}} error with type-safe decode functionality
type {{.Name}}ErrorDecoder struct {
	PackableError
}
{{- end}}

{{/* Generate type-specific decoders for methods */}}
{{- range .Contract.Methods}}
{{- if gt (len .Outputs) 0}}

// MustDecode decodes return values for {{.Name}} method
func (m *{{.Name | title}}Method) MustDecode(data []byte) {{if eq (len .Outputs) 1}}{{$output := index .Outputs 0}}{{formatGoType $output.Type}}{{else}}{{.Name | title}}Result{{end}} {
{{- if eq (len .Outputs) 1}}
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	{{- $output := index .Outputs 0}}
	{{- if eq $output.Type.TypeName "*big.Int"}}
	return mustDecodeUint256(data[0:32])
	{{- else if eq $output.Type.TypeName "uint64"}}
	return decodeUint64(data[0:32])
	{{- else if eq $output.Type.TypeName "uint8"}}
	return decodeUint8(data[0:32])
	{{- else if eq $output.Type.TypeName "uint16"}}
	return decodeUint16(data[0:32])
	{{- else if eq $output.Type.TypeName "uint32"}}
	return decodeUint32(data[0:32])
	{{- else if eq $output.Type.TypeName "int64"}}
	return decodeInt64(data[0:32])
	{{- else if eq $output.Type.TypeName "int8"}}
	return int8(decodeInt64(data[0:32]))
	{{- else if eq $output.Type.TypeName "int16"}}
	return int16(decodeInt64(data[0:32]))
	{{- else if eq $output.Type.TypeName "int32"}}
	return int32(decodeInt64(data[0:32]))
	{{- else if eq $output.Type.TypeName "bool"}}
	return decodeBool(data[0:32])
	{{- else if eq $output.Type.TypeName "Address"}}
	return decodeAddress(data[0:32])
	{{- else if eq $output.Type.TypeName "Hash"}}
	return decodeHash(data[0:32])
	{{- else if eq $output.Type.TypeName "string"}}
	result, _ := decodeString(data, 0)
	return result
	{{- else if eq $output.Type.TypeName "[]byte"}}
	result, _ := decodeBytes(data, 0)
	return result
	{{- else if eq $output.Type.TypeName "[1]byte"}}
	return decodeBytes1(data[0:32])
	{{- else if eq $output.Type.TypeName "[32]byte"}}
	return decodeBytes32(data[0:32])
	{{- else if eq $output.Type.TypeName "[]*big.Int"}}
	elems, _ := decodeArray(data, 0, decodeUint256ArrayElement)
	result := make([]*big.Int, len(elems))
	for i, elem := range elems {
		result[i] = elem.(*big.Int)
	}
	return result
	{{- else if eq $output.Type.TypeName "[]uint64"}}
	elems, _ := decodeArray(data, 0, func(d []byte) interface{} { return decodeUint64(d) })
	result := make([]uint64, len(elems))
	for i, elem := range elems {
		result[i] = elem.(uint64)
	}
	return result
	{{- else if eq $output.Type.TypeName "[]Address"}}
	elems, _ := decodeArray(data, 0, decodeAddressArrayElement)
	result := make([]Address, len(elems))
	for i, elem := range elems {
		result[i] = elem.(Address)
	}
	return result
	{{- else if and $output.Type.IsSlice (ne $output.Type.TypeName "[]*big.Int") (ne $output.Type.TypeName "[]uint64") (ne $output.Type.TypeName "[]Address")}}
	// Custom struct array type: {{$output.Type.TypeName}}
	if len(data) < 32 {
		panic("insufficient data for array length")
	}
	lengthBig := mustDecodeUint256(data[0:32])
	if !lengthBig.IsUint64() {
		panic("array length too large")
	}
	length := int(lengthBig.Uint64())
	
	// TODO: Implement proper struct decoding based on struct fields
	// For now, return empty array to avoid panic
	elemType := "{{$output.Type.TypeName}}"[2:] // Remove "[]" prefix to get struct name
	_ = elemType // Use elemType to generate proper struct decoding
	panic("struct array decoding requires struct field information for {{$output.Type.TypeName}}")
	{{- else}}
	// Unsupported return type: {{$output.Type.TypeName}}
	panic("unsupported return type: {{$output.Type.TypeName}}")
	{{- end}}
{{- else}}
	// Multiple return values - return as struct
	result := {{.Name | title}}Result{}
	offset := 0
	{{- range $i, $output := .Outputs}}
	{{- if eq $output.Type.TypeName "*big.Int"}}
	if len(data) < offset+32 {
		panic("insufficient data for return value {{$i}}")
	}
	result.{{$output.Name | title}} = mustDecodeUint256(data[offset:offset+32])
	offset += 32
	{{- else if eq $output.Type.TypeName "uint64"}}
	if len(data) < offset+32 {
		panic("insufficient data for return value {{$i}}")
	}
	result.{{$output.Name | title}} = decodeUint64(data[offset:offset+32])
	offset += 32
	{{- else if eq $output.Type.TypeName "int64"}}
	if len(data) < offset+32 {
		panic("insufficient data for return value {{$i}}")
	}
	result.{{$output.Name | title}} = decodeInt64(data[offset:offset+32])
	offset += 32
	{{- else if eq $output.Type.TypeName "bool"}}
	if len(data) < offset+32 {
		panic("insufficient data for return value {{$i}}")
	}
	result.{{$output.Name | title}} = decodeBool(data[offset:offset+32])
	offset += 32
	{{- else if eq $output.Type.TypeName "Address"}}
	if len(data) < offset+32 {
		panic("insufficient data for return value {{$i}}")
	}
	result.{{$output.Name | title}} = decodeAddress(data[offset:offset+32])
	offset += 32
	{{- else}}
	// Unsupported multi-return type: {{$output.Type.TypeName}}
	panic("unsupported multi-return type: {{$output.Type.TypeName}}")
	{{- end}}
	{{- end}}
	return result
{{- end}}
}
{{- end}}
{{- end}}

{{/* Generate type-specific decoders for events */}}
{{- range .Contract.Events}}

// MustDecode decodes log data for {{.Name}} event
func (e *{{.Name}}EventDecoder) MustDecode(data []byte) {{.Struct.Name}} {
	// Decode event parameters (only non-indexed parameters are in data)
	result := {{.Struct.Name}}{}
	{{- $hasNonIndexedParams := false}}
	{{- range $i, $input := .Inputs}}
	{{- if not $input.Indexed}}
	{{- $hasNonIndexedParams = true}}
	{{- end}}
	{{- end}}
	{{- if $hasNonIndexedParams}}
	offset := 0
	{{- range $i, $input := .Inputs}}
	{{- if not $input.Indexed}}
	{{- if eq $input.Type.TypeName "*big.Int"}}
	if len(data) < offset+32 {
		panic("insufficient data for event parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = mustDecodeUint256(data[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "uint64"}}
	if len(data) < offset+32 {
		panic("insufficient data for event parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeUint64(data[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "int64"}}
	if len(data) < offset+32 {
		panic("insufficient data for event parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeInt64(data[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "bool"}}
	if len(data) < offset+32 {
		panic("insufficient data for event parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeBool(data[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "Address"}}
	if len(data) < offset+32 {
		panic("insufficient data for event parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeAddress(data[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "string"}}
	var nextOffset int
	result.{{$input.Name | title}}, nextOffset = decodeString(data, offset)
	offset = nextOffset
	{{- else if eq $input.Type.TypeName "[]byte"}}
	var nextOffset int
	result.{{$input.Name | title}}, nextOffset = decodeBytes(data, offset)
	offset = nextOffset
	{{- else}}
	// Unsupported event parameter type: {{$input.Type.TypeName}}
	panic("unsupported event parameter type: {{$input.Type.TypeName}}")
	{{- end}}
	{{- end}}
	{{- end}}
	{{- else}}
	// Event has no non-indexed parameters, return empty struct
	{{- end}}
	return result
}
{{- end}}

{{/* Generate type-specific decoders for errors */}}
{{- range .Contract.Errors}}

// MustDecode decodes error data for {{.Name}} error
func (e *{{.Name}}ErrorDecoder) MustDecode(data []byte) {{.Struct.Name}} {
	// Skip the 4-byte selector
	if len(data) < 4 {
		panic("insufficient data for error selector")
	}
	errorData := data[4:]
	// Decode error parameters
	result := {{.Struct.Name}}{}
{{- if gt (len .Inputs) 0}}
	offset := 0
	{{- range $i, $input := .Inputs}}
	{{- if eq $input.Type.TypeName "*big.Int"}}
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = mustDecodeUint256(errorData[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "uint64"}}
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeUint64(errorData[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "int64"}}
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeInt64(errorData[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "bool"}}
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeBool(errorData[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "Address"}}
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter {{$input.Name}}")
	}
	result.{{$input.Name | title}} = decodeAddress(errorData[offset:offset+32])
	offset += 32
	{{- else if eq $input.Type.TypeName "string"}}
	var nextOffset int
	result.{{$input.Name | title}}, nextOffset = decodeString(errorData, offset)
	offset = nextOffset
	{{- else if eq $input.Type.TypeName "[]byte"}}
	var nextOffset int
	result.{{$input.Name | title}}, nextOffset = decodeBytes(errorData, offset)
	offset = nextOffset
	{{- else}}
	// Unsupported error parameter type: {{$input.Type.TypeName}}
	panic("unsupported error parameter type: {{$input.Type.TypeName}}")
	{{- end}}
	{{- end}}
{{- end}}
	return result
}
{{- end}}

`