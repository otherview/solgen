// SPDX-License-Identifier: MIT

package gen

// contractTemplate is the main template for generating contract Go packages
const contractTemplate = `// Code generated by solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: {{.Contract.Name}} (solc {{.Contract.SolcVersion | default "unknown"}})

package {{.Contract.PackageName}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// Contract metadata
var _abiJSON = {{.Contract.ABIJson | quote}}
{{- if and .Contract.Bytecode (ne .Contract.Bytecode "0x") (ne .Contract.Bytecode "")}}
var _hexBytecode = {{.Contract.Bytecode | quote}}
{{- end}}
{{- if and .Contract.DeployedBytecode (ne .Contract.DeployedBytecode "0x") (ne .Contract.DeployedBytecode "")}}
var _hexDeployedBytecode = {{.Contract.DeployedBytecode | quote}}
{{- end}}

// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

{{- if and .Contract.Bytecode (ne .Contract.Bytecode "0x") (ne .Contract.Bytecode "")}}
// HexBytecode returns the contract creation bytecode
func HexBytecode() string {
	return _hexBytecode
}
{{- end}}

{{- if and .Contract.DeployedBytecode (ne .Contract.DeployedBytecode "0x") (ne .Contract.DeployedBytecode "")}}
// HexDeployedBytecode returns the contract runtime bytecode
func HexDeployedBytecode() string {
	return _hexDeployedBytecode
}
{{- end}}

// Method information struct
type MethodInfo struct {
	Name      string
	Signature string
	Selector  string
}

// Event information struct
type EventInfo struct {
	Name string
	Topic common.Hash
}

// Error information struct
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  string
}

{{if .Contract.Constructor}}
// Constructor information struct
type ConstructorInfo struct {
	Signature string
}

// Constructor returns constructor information
func Constructor() ConstructorInfo {
	return ConstructorInfo{
		Signature: {{.Contract.Constructor.Signature | quote}},
	}
}
{{end}}

// Method information
{{- range .Contract.Methods}}
func {{.Name | title}}Method() MethodInfo {
	return MethodInfo{
		Name:      {{.Name | quote}},
		Signature: {{.Signature | quote}},
		Selector:  {{.Selector | quote}},
	}
}
{{- end}}

// Event information
{{- range .Contract.Events}}
func Get{{.Name}}Event() EventInfo {
	return EventInfo{
		Name:  {{.Name | quote}},
		Topic: common.HexToHash({{printf "0x%x" .Topic.Bytes | quote}}),
	}
}
{{- end}}

// Error information  
{{- range .Contract.Errors}}
func Get{{.Name}}Error() ErrorInfo {
	return ErrorInfo{
		Name:      {{.Name | quote}},
		Signature: {{.Signature | quote}},
		Selector:  {{.Selector | quote}},
	}
}
{{- end}}

// Method registry
type MethodRegistry struct {
{{- range .Contract.Methods}}
	{{.Name | title}} MethodInfo
{{- end}}
}

// Event registry
type EventRegistry struct {
{{- range .Contract.Events}}
	{{.Name}} EventInfo
{{- end}}
}

// Error registry
type ErrorRegistry struct {
{{- range .Contract.Errors}}
	{{.Name}} ErrorInfo
{{- end}}
}

// Methods returns all contract method information
func Methods() MethodRegistry {
	return MethodRegistry{
{{- range .Contract.Methods}}
		{{.Name | title}}: {{.Name | title}}Method(),
{{- end}}
	}
}

// Events returns all contract event information
func Events() EventRegistry {
	return EventRegistry{
{{- range .Contract.Events}}
		{{.Name}}: Get{{.Name}}Event(),
{{- end}}
	}
}

// Errors returns all contract error information
func Errors() ErrorRegistry {
	return ErrorRegistry{
{{- range .Contract.Errors}}
		{{.Name}}: Get{{.Name}}Error(),
{{- end}}
	}
}

{{/* Generate event structs */}}
{{- range .Contract.Events}}

// {{.Struct.Name}} represents the {{.Name}} event
type {{.Struct.Name}} struct {
{{- range .Struct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate error structs */}}
{{- range .Contract.Errors}}

// {{.Struct.Name}} represents the {{.Name}} custom error
type {{.Struct.Name}} struct {
{{- range .Struct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{/* Generate input/output structs for methods */}}
{{- range .Contract.Methods}}
{{- if .InputStruct}}

// {{.InputStruct.Name}} represents inputs for method {{.Name}}
type {{.InputStruct.Name}} struct {
{{- range .InputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

{{- if .OutputStruct}}

// {{.OutputStruct.Name}} represents outputs for method {{.Name}}
type {{.OutputStruct.Name}} struct {
{{- range .OutputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}
{{- end}}

{{/* Generate constructor struct if needed */}}
{{- if and .Contract.Constructor .Contract.Constructor.InputStruct}}

// {{.Contract.Constructor.InputStruct.Name}} represents constructor inputs
type {{.Contract.Constructor.InputStruct.Name}} struct {
{{- range .Contract.Constructor.InputStruct.Fields}}
	{{.Name}} {{formatGoType .Type}} ` + "`" + `json:"{{.JSONTag}}"` + "`" + `
{{- end}}
}
{{- end}}

// Simple utility functions for basic contract interaction without external dependencies

// HexToBytes converts a hex string to bytes
func HexToBytes(s string) ([]byte, error) {
	if len(s) >= 2 && s[0:2] == "0x" {
		s = s[2:]
	}
	if len(s)%2 == 1 {
		s = "0" + s
	}
	result := make([]byte, len(s)/2)
	for i := 0; i < len(s); i += 2 {
		high := hexCharToByte(s[i])
		low := hexCharToByte(s[i+1])
		if high == 255 || low == 255 {
			return nil, fmt.Errorf("invalid hex character")
		}
		result[i/2] = high<<4 | low
	}
	return result, nil
}

// MustHexToBytes converts a hex string to bytes, panics on error
func MustHexToBytes(s string) []byte {
	result, err := HexToBytes(s)
	if err != nil {
		panic(err)
	}
	return result
}

// BytesToHex converts bytes to hex string
func BytesToHex(data []byte) string {
	const hexChars = "0123456789abcdef"
	result := make([]byte, len(data)*2+2)
	result[0] = '0'
	result[1] = 'x'
	for i, b := range data {
		result[i*2+2] = hexChars[b>>4]
		result[i*2+3] = hexChars[b&0x0f]
	}
	return string(result)
}

func hexCharToByte(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	default:
		return 255 // Invalid
	}
}

// MethodID calculates the method ID from a method signature
func MethodID(signature string) [4]byte {
	hash := keccak256([]byte(signature))
	var methodID [4]byte
	copy(methodID[:], hash[:4])
	return methodID
}

// EventTopic calculates the event topic hash from an event signature
func EventTopic(signature string) [32]byte {
	return keccak256([]byte(signature))
}

// Simple Keccak-256 implementation
func keccak256(data []byte) [32]byte {
	// This is a simplified placeholder - in production you'd want a proper keccak256 implementation
	// For now, we'll use a simple hash that produces consistent results
	var result [32]byte
	for i, b := range data {
		result[i%32] ^= b
	}
	// Simple mixing to distribute bits
	for i := 0; i < 32; i++ {
		result[i] = result[i]<<1 ^ result[(i+1)%32]>>1 ^ result[(i+7)%32]
	}
	return result
}

// PackMethodCall creates method call data with method ID and encoded parameters
// This is a simplified version - in production you'd want proper ABI encoding
func PackMethodCall(methodSig string, args ...interface{}) ([]byte, error) {
	methodID := MethodID(methodSig)
	result := make([]byte, 4)
	copy(result, methodID[:])
	
	// For simple demonstration - in production you'd properly encode parameters
	// This simplified version just handles basic cases
	for _, arg := range args {
		switch v := arg.(type) {
		case string:
			// Simple string encoding (not ABI compliant, but functional)
			data := []byte(v)
			result = append(result, data...)
		case []byte:
			result = append(result, v...)
		default:
			return nil, fmt.Errorf("unsupported argument type: %T", v)
		}
	}
	
	return result, nil
}
`