// SPDX-License-Identifier: MIT

package gen

// contractTemplate is the main template for generating contract Go packages
const contractTemplate = `// Code generated by github.com/otherview/solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: {{.Contract.Name}} (solc {{.Contract.SolcVersion | default "unknown"}})

package {{.Contract.PackageName}}

import (
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"strings"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// Contract metadata
var _abiJSON = {{.Contract.ABIJson | quote}}


// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

{{- if and .Contract.Bytecode (ne .Contract.Bytecode.Hex "0x") (ne .Contract.Bytecode.Hex "")}}
// Bytecode contains the contract creation bytecode
var Bytecode = HexData({{.Contract.Bytecode.Hex | quote}})
{{- end}}

{{- if and .Contract.DeployedBytecode (ne .Contract.DeployedBytecode.Hex "0x") (ne .Contract.DeployedBytecode.Hex "")}}
// DeployedBytecode contains the contract runtime bytecode  
var DeployedBytecode = HexData({{.Contract.DeployedBytecode.Hex | quote}})
{{- end}}

// Address represents a 20-byte Ethereum address
type Address [20]byte

// String returns the hex string representation of the address
func (a Address) String() string {
	return "0x" + hex.EncodeToString(a[:])
}

// Hash represents a 32-byte hash
type Hash [32]byte

// String returns the hex string representation of the hash
func (h Hash) String() string {
	return "0x" + hex.EncodeToString(h[:])
}

// Bytes returns the hash as a byte slice
func (h Hash) Bytes() []byte {
	return h[:]
}

// AddressFromHex creates an Address from a hex string
func AddressFromHex(s string) Address {
	var addr Address
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 40 {
		panic("invalid address hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid address hex string: " + err.Error())
	}
	copy(addr[:], decoded)
	return addr
}

// HashFromHex creates a Hash from a hex string
func HashFromHex(s string) Hash {
	var hash Hash
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 64 {
		panic("invalid hash hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hash hex string: " + err.Error())
	}
	copy(hash[:], decoded)
	return hash
}

// HexData provides convenient access to hex-encoded byte data
type HexData string

// Hex returns the hex string representation
func (h HexData) Hex() string {
	return string(h)
}

// Bytes returns the decoded bytes from the hex string
func (h HexData) Bytes() []byte {
	hexStr := string(h)
	if hexStr == "" {
		return nil
	}
	if strings.HasPrefix(hexStr, "0x") {
		hexStr = hexStr[2:]
	}
	decoded, err := hex.DecodeString(hexStr)
	if err != nil {
		panic("invalid hex data: " + err.Error())
	}
	return decoded
}

` + encodingHelpersTemplate + `

` + decodingHelpersTemplate + `

// Method information
{{- range .Contract.Methods}}
func Get{{.Name | title}}Method() MethodInfo {
	return MethodInfo{
		Name:      {{.Name | quote}},
		Signature: {{.Signature | quote}},
		Selector:  HexData({{.Selector.Hex | quote}}),
	}
}
{{- end}}

// Event information
{{- range .Contract.Events}}
func Get{{.Name | title}}Event() EventInfo {
	return EventInfo{
		Name:  {{.Name | quote}},
		Topic: HashFromHex({{printf "0x%x" .Topic.Bytes | quote}}),
	}
}
{{- end}}

// Error information  
{{- range .Contract.Errors}}
func Get{{.Name}}Error() ErrorInfo {
	return ErrorInfo{
		Name:      {{.Name | quote}},
		Signature: {{.Signature | quote}},
		Selector:  HexData({{.Selector.Hex | quote}}),
	}
}
{{- end}}

// Method registry provides access to packable contract methods
type MethodRegistry struct{}

// Event registry provides access to packable contract events
type EventRegistry struct{}

// Error registry provides access to packable contract errors
type ErrorRegistry struct{}

// PackableMethod represents a method with packing capabilities
type PackableMethod struct {
	Name      string
	Signature string
	Selector  HexData
}

// PackableEvent represents an event with unpacking capabilities
type PackableEvent struct {
	Name  string
	Topic Hash
}

// EventDecoder represents an event with decode functionality
type EventDecoder struct {
	Name  string
	Topic Hash
}

// PackableError represents an error with unpacking capabilities
type PackableError struct {
	Name      string
	Signature string
	Selector  HexData
}

// MethodInfo represents method metadata
type MethodInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// EventInfo represents event metadata
type EventInfo struct {
	Name  string
	Topic Hash
}

// ErrorInfo represents error metadata
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// Pack encodes method arguments and returns the method selector + encoded arguments
func (pm *PackableMethod) Pack(args ...any) (HexData, error) {
	// Start with the 4-byte method selector
	selectorBytes := pm.Selector.Bytes()
	if len(selectorBytes) == 0 {
		return "", fmt.Errorf("invalid method selector")
	}
	
	// If no arguments, return just the selector
	if len(args) == 0 {
		return pm.Selector, nil
	}
	
	// Encode arguments using our ABI implementation
	var encodedArgs []byte
	for _, arg := range args {
		switch v := arg.(type) {
		case *big.Int:
			data, err := encodeUint256(v)
			if err != nil {
				return "", fmt.Errorf("encoding big.Int: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case Address:
			data, err := encodeAddress(v)
			if err != nil {
				return "", fmt.Errorf("encoding address: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case bool:
			data, err := encodeBool(v)
			if err != nil {
				return "", fmt.Errorf("encoding bool: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case string:
			data, err := encodeString(v)
			if err != nil {
				return "", fmt.Errorf("encoding string: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case []byte:
			data, err := encodeBytes(v)
			if err != nil {
				return "", fmt.Errorf("encoding bytes: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		default:
			return "", fmt.Errorf("unsupported argument type: %T", arg)
		}
	}
	
	// Combine selector and encoded arguments
	result := hex.EncodeToString(append(selectorBytes, encodedArgs...))
	return HexData("0x" + result), nil
}

// MustPack encodes method arguments and panics on error
func (pm *PackableMethod) MustPack(args ...any) HexData {
	result, err := pm.Pack(args...)
	if err != nil {
		panic(err)
	}
	return result
}

` + methodRegistryTemplate + `

` + eventRegistryTemplate + `

` + errorRegistryTemplate + `

` + structDefinitionsTemplate + `

` + structDecodersTemplate + `

` + methodDecodersTemplate + `

` + eventDecodersTemplate + `

` + errorDecodersTemplate + `

`