// Code generated by github.com/otherview/solgen. DO NOT EDIT.
// SPDX-License-Identifier: MIT
// Contract: SimpleToken (solc 0.8.30+commit.73712a01.Linux.clang)

package simpletoken

import (
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"strings"
)

// Contract metadata
var _abiJSON = "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// ABI returns the contract ABI as a JSON string
func ABI() string {
	return _abiJSON
}

// Address represents a 20-byte Ethereum address
type Address [20]byte

// String returns the hex string representation of the address
func (a Address) String() string {
	return "0x" + hex.EncodeToString(a[:])
}

// Hash represents a 32-byte hash
type Hash [32]byte

// String returns the hex string representation of the hash
func (h Hash) String() string {
	return "0x" + hex.EncodeToString(h[:])
}

// Bytes returns the hash as a byte slice
func (h Hash) Bytes() []byte {
	return h[:]
}

// AddressFromHex creates an Address from a hex string
func AddressFromHex(s string) Address {
	var addr Address
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 40 {
		panic("invalid address hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid address hex string: " + err.Error())
	}
	copy(addr[:], decoded)
	return addr
}

// HashFromHex creates a Hash from a hex string
func HashFromHex(s string) Hash {
	var hash Hash
	if strings.HasPrefix(s, "0x") {
		s = s[2:]
	}
	if len(s) != 64 {
		panic("invalid hash hex string length")
	}
	decoded, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hash hex string: " + err.Error())
	}
	copy(hash[:], decoded)
	return hash
}

// HexData provides convenient access to hex-encoded byte data
type HexData string

// Hex returns the hex string representation
func (h HexData) Hex() string {
	return string(h)
}

// Bytes returns the decoded bytes from the hex string
func (h HexData) Bytes() []byte {
	hexStr := string(h)
	if hexStr == "" {
		return nil
	}

	// Remove 0x prefix if present
	if len(hexStr) >= 2 && hexStr[:2] == "0x" {
		hexStr = hexStr[2:]
	}

	if hexStr == "" {
		return nil
	}

	data, err := hex.DecodeString(hexStr)
	if err != nil {
		panic("invalid hex string in generated code: " + string(h))
	}
	return data
}

// ABI Encoding/Decoding Implementation

// encodeUint256 encodes a uint256 value to 32 bytes (big-endian)
func encodeUint256(val interface{}) ([]byte, error) {
	result := make([]byte, 32)
	switch v := val.(type) {
	case *big.Int:
		if v.Sign() < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		if v.BitLen() > 256 {
			return nil, errors.New("value too large for uint256")
		}
		v.FillBytes(result)
		return result, nil
	case uint64:
		big.NewInt(0).SetUint64(v).FillBytes(result)
		return result, nil
	case int64:
		if v < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		big.NewInt(v).FillBytes(result)
		return result, nil
	case int:
		if v < 0 {
			return nil, errors.New("negative values not supported for uint256")
		}
		big.NewInt(int64(v)).FillBytes(result)
		return result, nil
	default:
		return nil, fmt.Errorf("unsupported type for uint256: %T", v)
	}
}

// mustEncodeUint256 encodes a uint256 value, panics on error
func mustEncodeUint256(val interface{}) []byte {
	result, err := encodeUint256(val)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeAddress encodes an address to 32 bytes (left-padded with zeros)
func encodeAddress(addr Address) []byte {
	result := make([]byte, 32)
	copy(result[12:], addr[:])
	return result
}

// encodeBool encodes a boolean to 32 bytes
func encodeBool(val bool) []byte {
	result := make([]byte, 32)
	if val {
		result[31] = 1
	}
	return result
}

// encodeBytes encodes dynamic bytes
func encodeBytes(data []byte) []byte {
	// Length + data + padding
	length := mustEncodeUint256(uint64(len(data)))
	padded := make([]byte, ((len(data)+31)/32)*32) // Pad to multiple of 32
	copy(padded, data)
	return append(length, padded...)
}

// encodeInt256 encodes a signed 256-bit integer to 32 bytes (two's complement)
func encodeInt256(val interface{}) ([]byte, error) {
	result := make([]byte, 32)
	switch v := val.(type) {
	case *big.Int:
		if v.BitLen() > 255 { // 255 bits for magnitude + 1 for sign
			return nil, errors.New("value too large for int256")
		}
		if v.Sign() >= 0 {
			v.FillBytes(result)
		} else {
			// Two's complement for negative numbers
			pos := new(big.Int).Abs(v)
			pos.FillBytes(result)
			// Flip bits
			for i := range result {
				result[i] = ^result[i]
			}
			// Add 1
			carry := byte(1)
			for i := 31; i >= 0 && carry > 0; i-- {
				sum := int(result[i]) + int(carry)
				result[i] = byte(sum)
				carry = byte(sum >> 8)
			}
		}
		return result, nil
	case int64:
		big.NewInt(v).FillBytes(result)
		if v < 0 {
			return encodeInt256(big.NewInt(v))
		}
		return result, nil
	case int:
		return encodeInt256(int64(v))
	default:
		return nil, fmt.Errorf("unsupported type for int256: %T", v)
	}
}

// mustEncodeInt256 encodes a signed 256-bit integer, panics on error
func mustEncodeInt256(val interface{}) []byte {
	result, err := encodeInt256(val)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeFixedBytes encodes fixed-size bytes (e.g., bytes32)
func encodeFixedBytes(data []byte, size int) []byte {
	if len(data) > size {
		panic(fmt.Sprintf("data too large for bytes%d: got %d bytes", size, len(data)))
	}
	result := make([]byte, 32)
	copy(result[:len(data)], data)
	return result
}

// encodeArray encodes dynamic or fixed arrays
func encodeArray(elements []interface{}) ([]byte, error) {
	if len(elements) == 0 {
		return mustEncodeUint256(uint64(0)), nil
	}

	// For dynamic arrays, start with length
	result := mustEncodeUint256(uint64(len(elements)))

	// Encode each element
	for _, elem := range elements {
		switch v := elem.(type) {
		case *big.Int:
			data, err := encodeUint256(v)
			if err != nil {
				return nil, fmt.Errorf("encoding array element: %w", err)
			}
			result = append(result, data...)
		case uint64:
			result = append(result, mustEncodeUint256(v)...)
		case Address:
			result = append(result, encodeAddress(v)...)
		case bool:
			result = append(result, encodeBool(v)...)
		default:
			return nil, fmt.Errorf("unsupported array element type: %T", v)
		}
	}

	return result, nil
}

// mustEncodeArray encodes an array, panics on error
func mustEncodeArray(elements []interface{}) []byte {
	result, err := encodeArray(elements)
	if err != nil {
		panic(err)
	}
	return result
}

// encodeString encodes a string as dynamic bytes
func encodeString(str string) []byte {
	return encodeBytes([]byte(str))
}

// decodeUint256 decodes a uint256 from 32 bytes to *big.Int
func decodeUint256(data []byte) (*big.Int, error) {
	if len(data) < 32 {
		return nil, errors.New("insufficient data for uint256")
	}
	return new(big.Int).SetBytes(data[:32]), nil
}

// mustDecodeUint256 decodes a uint256, panics on error
func mustDecodeUint256(data []byte) *big.Int {
	result, err := decodeUint256(data)
	if err != nil {
		panic(err)
	}
	return result
}

// decodeInt256 decodes a signed 256-bit integer from 32 bytes
func decodeInt256(data []byte) (*big.Int, error) {
	if len(data) < 32 {
		return nil, errors.New("insufficient data for int256")
	}

	result := new(big.Int).SetBytes(data[:32])

	// Check if negative (MSB is set)
	if data[0]&0x80 != 0 {
		// Convert from two's complement
		// Create mask with all bits set for 256-bit number
		mask := new(big.Int).Lsh(big.NewInt(1), 256)
		mask.Sub(mask, big.NewInt(1))

		// XOR with mask and add 1 to get absolute value
		result.Xor(result, mask)
		result.Add(result, big.NewInt(1))
		result.Neg(result)
	}

	return result, nil
}

// mustDecodeInt256 decodes a signed 256-bit integer, panics on error
func mustDecodeInt256(data []byte) *big.Int {
	result, err := decodeInt256(data)
	if err != nil {
		panic(err)
	}
	return result
}

// decodeAddress decodes an address from 32 bytes
func decodeAddress(data []byte) Address {
	if len(data) < 32 {
		panic("insufficient data for address")
	}
	var addr Address
	copy(addr[:], data[12:32])
	return addr
}

// decodeBool decodes a boolean from 32 bytes
func decodeBool(data []byte) bool {
	if len(data) < 32 {
		panic("insufficient data for bool")
	}
	return data[31] != 0
}

// decodeBytes decodes dynamic bytes
func decodeBytes(data []byte, offset int) ([]byte, int) {
	if len(data) < offset+32 {
		panic("insufficient data for bytes length")
	}
	lengthBig := mustDecodeUint256(data[offset : offset+32])
	if !lengthBig.IsUint64() {
		panic("bytes length too large")
	}
	length := int(lengthBig.Uint64())
	if len(data) < offset+32+length {
		panic("insufficient data for bytes content")
	}
	result := make([]byte, length)
	copy(result, data[offset+32:offset+32+length])
	// Calculate next offset (padded to 32 bytes)
	paddedLength := ((length + 31) / 32) * 32
	return result, offset + 32 + paddedLength
}

// decodeFixedBytes decodes fixed-size bytes (e.g., bytes32)
func decodeFixedBytes(data []byte, size int) []byte {
	if len(data) < 32 {
		panic("insufficient data for fixed bytes")
	}
	if size > 32 {
		panic("fixed bytes size too large")
	}
	result := make([]byte, size)
	copy(result, data[:size])
	return result
}

// decode various fixed-size byte arrays
func decodeBytes1(data []byte) [1]byte {
	var result [1]byte
	copy(result[:], decodeFixedBytes(data, 1))
	return result
}

func decodeBytes32(data []byte) [32]byte {
	var result [32]byte
	copy(result[:], decodeFixedBytes(data, 32))
	return result
}

// decodeArray decodes dynamic arrays
func decodeArray(data []byte, offset int, elemDecoder func([]byte) interface{}) ([]interface{}, int) {
	if len(data) < offset+32 {
		panic("insufficient data for array length")
	}

	lengthBig := mustDecodeUint256(data[offset : offset+32])
	if !lengthBig.IsUint64() {
		panic("array length too large")
	}
	length := int(lengthBig.Uint64())

	currentOffset := offset + 32
	result := make([]interface{}, length)

	for i := 0; i < length; i++ {
		if len(data) < currentOffset+32 {
			panic(fmt.Sprintf("insufficient data for array element %d", i))
		}
		result[i] = elemDecoder(data[currentOffset : currentOffset+32])
		currentOffset += 32
	}

	return result, currentOffset
}

// Array element decoders (internal use)
func decodeUint256ArrayElement(data []byte) interface{} {
	return mustDecodeUint256(data)
}

func decodeAddressArrayElement(data []byte) interface{} {
	return decodeAddress(data)
}

func decodeBoolArrayElement(data []byte) interface{} {
	return decodeBool(data)
}

// decodeUint8 decodes a uint8 from 32 bytes
func decodeUint8(data []byte) uint8 {
	if len(data) < 32 {
		panic("insufficient data for uint8")
	}
	// Verify upper bytes are zero
	for i := 0; i < 31; i++ {
		if data[i] != 0 {
			panic("invalid uint8 encoding")
		}
	}
	return data[31]
}

// decodeUint16 decodes a uint16 from 32 bytes
func decodeUint16(data []byte) uint16 {
	if len(data) < 32 {
		panic("insufficient data for uint16")
	}
	// Verify upper bytes are zero
	for i := 0; i < 30; i++ {
		if data[i] != 0 {
			panic("invalid uint16 encoding")
		}
	}
	return uint16(data[30])<<8 | uint16(data[31])
}

// decodeUint32 decodes a uint32 from 32 bytes
func decodeUint32(data []byte) uint32 {
	if len(data) < 32 {
		panic("insufficient data for uint32")
	}
	// Verify upper bytes are zero
	for i := 0; i < 28; i++ {
		if data[i] != 0 {
			panic("invalid uint32 encoding")
		}
	}
	var result uint32
	for i := 28; i < 32; i++ {
		result = (result << 8) | uint32(data[i])
	}
	return result
}

// decodeUint64 decodes a uint64 from 32 bytes
func decodeUint64(data []byte) uint64 {
	if len(data) < 32 {
		panic("insufficient data for uint64")
	}
	// Check if value exceeds uint64 range
	for i := 0; i < 24; i++ {
		if data[i] != 0 {
			panic("value exceeds uint64 range")
		}
	}
	var result uint64
	for i := 24; i < 32; i++ {
		result = (result << 8) | uint64(data[i])
	}
	return result
}

// decodeInt64 decodes a int64 from 32 bytes
func decodeInt64(data []byte) int64 {
	if len(data) < 32 {
		panic("insufficient data for int64")
	}

	// Check if this is a negative number (MSB set)
	isNegative := data[0]&0x80 != 0

	// Verify upper bytes are consistent (all 0s or all 1s for sign extension)
	expectedByte := byte(0)
	if isNegative {
		expectedByte = 0xFF
	}

	for i := 0; i < 24; i++ {
		if data[i] != expectedByte {
			panic("value exceeds int64 range")
		}
	}

	var result int64
	for i := 24; i < 32; i++ {
		result = (result << 8) | int64(data[i])
	}

	// Sign extend if necessary
	if isNegative {
		result |= ^((1 << 32) - 1) // Set upper 32 bits
	}

	return result
}

// decodeHash decodes a 32-byte hash
func decodeHash(data []byte) Hash {
	if len(data) < 32 {
		panic("insufficient data for hash")
	}
	var hash Hash
	copy(hash[:], data[:32])
	return hash
}

// decodeString decodes a string from dynamic bytes
func decodeString(data []byte, offset int) (string, int) {
	bytes, nextOffset := decodeBytes(data, offset)
	return string(bytes), nextOffset
}

// Bytecode contains the contract creation bytecode
var Bytecode = HexData("0x608060405234801561000f575f5ffd5b50604051610c95380380610c9583398101604081905261002e91610134565b5f6100398482610225565b5060016100468382610225565b506002819055335f818152600360209081526040808320859055518481527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a35050506102df565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126100ba575f5ffd5b81516001600160401b038111156100d3576100d3610097565b604051601f8201601f19908116603f011681016001600160401b038111828210171561010157610101610097565b604052818152838201602001851015610118575f5ffd5b8160208501602083015e5f918101602001919091529392505050565b5f5f5f60608486031215610146575f5ffd5b83516001600160401b0381111561015b575f5ffd5b610167868287016100ab565b602086015190945090506001600160401b03811115610184575f5ffd5b610190868287016100ab565b925050604084015190509250925092565b600181811c908216806101b557607f821691505b6020821081036101d357634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561022057805f5260205f20601f840160051c810160208510156101fe5750805b601f840160051c820191505b8181101561021d575f815560010161020a565b50505b505050565b81516001600160401b0381111561023e5761023e610097565b6102528161024c84546101a1565b846101d9565b6020601f821160018114610284575f831561026d5750848201515b5f19600385901b1c1916600184901b17845561021d565b5f84815260208120601f198516915b828110156102b35787850151825560209485019460019092019101610293565b50848210156102d057868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b6109a9806102ec5f395ff3fe608060405234801561000f575f5ffd5b50600436106100a6575f3560e01c806323b872dd1161006e57806323b872dd1461012757806340c10f191461013a57806370a082311461014d57806395d89b411461016c578063a9059cbb14610174578063dd62ed3e14610187575f5ffd5b806306fdde03146100aa578063095ea7b3146100c857806312065fe0146100eb57806318160ddd146101095780631e89d54514610112575b5f5ffd5b6100b26101b1565b6040516100bf9190610655565b60405180910390f35b6100db6100d63660046106a5565b61023c565b60405190151581526020016100bf565b335f908152600360205260409020545b6040519081526020016100bf565b6100fb60025481565b61012561012036600461079f565b6102a8565b005b6100db610135366004610862565b61034b565b6101256101483660046106a5565b6104e5565b6100fb61015b36600461089c565b60036020525f908152604090205481565b6100b261056d565b6100db6101823660046106a5565b61057a565b6100fb6101953660046108bc565b600460209081525f928352604080842090915290825290205481565b5f80546101bd906108ed565b80601f01602080910402602001604051908101604052809291908181526020018280546101e9906108ed565b80156102345780601f1061020b57610100808354040283529160200191610234565b820191905f5260205f20905b81548152906001019060200180831161021757829003601f168201915b505050505081565b335f8181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906102969086815260200190565b60405180910390a35060015b92915050565b80518251146102f65760405162461bcd60e51b8152602060048201526015602482015274082e4e4c2f240d8cadccee8d040dad2e6dac2e8c6d605b1b60448201526064015b60405180910390fd5b5f5b82518110156103465761033d83828151811061031657610316610925565b602002602001015183838151811061033057610330610925565b602002602001015161057a565b506001016102f8565b505050565b6001600160a01b0383165f908152600460209081526040808320338452909152812054828110156103ae5760405163246fb68960e21b81526001600160a01b038616600482015233602482015260448101849052606481018290526084016102ed565b6001600160a01b0385165f9081526003602052604090205483111561040f576001600160a01b0385165f818152600360205260409081902054905163db42144d60e01b815260048101929092526024820185905260448201526064016102ed565b610419838261094d565b6001600160a01b0386165f8181526004602090815260408083203384528252808320949094559181526003909152908120805485929061045a90849061094d565b90915550506001600160a01b0384165f9081526003602052604081208054859290610486908490610960565b92505081905550836001600160a01b0316856001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040516104d291815260200190565b60405180910390a3506001949350505050565b6001600160a01b0382165f908152600360205260408120805483929061050c908490610960565b925050819055508060025f8282546105249190610960565b90915550506040518181526001600160a01b038316905f907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a35050565b600180546101bd906108ed565b335f908152600360205260408120548211156105c957335f818152600360205260409081902054905163db42144d60e01b815260048101929092526024820184905260448201526064016102ed565b335f90815260036020526040812080548492906105e790849061094d565b90915550506001600160a01b0383165f9081526003602052604081208054849290610613908490610960565b90915550506040518281526001600160a01b0384169033907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90602001610296565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b03811681146106a0575f5ffd5b919050565b5f5f604083850312156106b6575f5ffd5b6106bf8361068a565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561070a5761070a6106cd565b604052919050565b5f67ffffffffffffffff82111561072b5761072b6106cd565b5060051b60200190565b5f82601f830112610744575f5ffd5b813561075761075282610712565b6106e1565b8082825260208201915060208360051b860101925085831115610778575f5ffd5b602085015b8381101561079557803583526020928301920161077d565b5095945050505050565b5f5f604083850312156107b0575f5ffd5b823567ffffffffffffffff8111156107c6575f5ffd5b8301601f810185136107d6575f5ffd5b80356107e461075282610712565b8082825260208201915060208360051b850101925087831115610805575f5ffd5b6020840193505b8284101561082e5761081d8461068a565b82526020938401939091019061080c565b9450505050602083013567ffffffffffffffff81111561084c575f5ffd5b61085885828601610735565b9150509250929050565b5f5f5f60608486031215610874575f5ffd5b61087d8461068a565b925061088b6020850161068a565b929592945050506040919091013590565b5f602082840312156108ac575f5ffd5b6108b58261068a565b9392505050565b5f5f604083850312156108cd575f5ffd5b6108d68361068a565b91506108e46020840161068a565b90509250929050565b600181811c9082168061090157607f821691505b60208210810361091f57634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b818103818111156102a2576102a2610939565b808201808211156102a2576102a261093956fea264697066735822122052f2510fe498a98a316e559058454f6a46b71930b92d6384ed7f0ed8f1101c4e64736f6c634300081e0033")

// DeployedBytecode contains the contract runtime bytecode
var DeployedBytecode = HexData("0x608060405234801561000f575f5ffd5b50600436106100a6575f3560e01c806323b872dd1161006e57806323b872dd1461012757806340c10f191461013a57806370a082311461014d57806395d89b411461016c578063a9059cbb14610174578063dd62ed3e14610187575f5ffd5b806306fdde03146100aa578063095ea7b3146100c857806312065fe0146100eb57806318160ddd146101095780631e89d54514610112575b5f5ffd5b6100b26101b1565b6040516100bf9190610655565b60405180910390f35b6100db6100d63660046106a5565b61023c565b60405190151581526020016100bf565b335f908152600360205260409020545b6040519081526020016100bf565b6100fb60025481565b61012561012036600461079f565b6102a8565b005b6100db610135366004610862565b61034b565b6101256101483660046106a5565b6104e5565b6100fb61015b36600461089c565b60036020525f908152604090205481565b6100b261056d565b6100db6101823660046106a5565b61057a565b6100fb6101953660046108bc565b600460209081525f928352604080842090915290825290205481565b5f80546101bd906108ed565b80601f01602080910402602001604051908101604052809291908181526020018280546101e9906108ed565b80156102345780601f1061020b57610100808354040283529160200191610234565b820191905f5260205f20905b81548152906001019060200180831161021757829003601f168201915b505050505081565b335f8181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906102969086815260200190565b60405180910390a35060015b92915050565b80518251146102f65760405162461bcd60e51b8152602060048201526015602482015274082e4e4c2f240d8cadccee8d040dad2e6dac2e8c6d605b1b60448201526064015b60405180910390fd5b5f5b82518110156103465761033d83828151811061031657610316610925565b602002602001015183838151811061033057610330610925565b602002602001015161057a565b506001016102f8565b505050565b6001600160a01b0383165f908152600460209081526040808320338452909152812054828110156103ae5760405163246fb68960e21b81526001600160a01b038616600482015233602482015260448101849052606481018290526084016102ed565b6001600160a01b0385165f9081526003602052604090205483111561040f576001600160a01b0385165f818152600360205260409081902054905163db42144d60e01b815260048101929092526024820185905260448201526064016102ed565b610419838261094d565b6001600160a01b0386165f8181526004602090815260408083203384528252808320949094559181526003909152908120805485929061045a90849061094d565b90915550506001600160a01b0384165f9081526003602052604081208054859290610486908490610960565b92505081905550836001600160a01b0316856001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040516104d291815260200190565b60405180910390a3506001949350505050565b6001600160a01b0382165f908152600360205260408120805483929061050c908490610960565b925050819055508060025f8282546105249190610960565b90915550506040518181526001600160a01b038316905f907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a35050565b600180546101bd906108ed565b335f908152600360205260408120548211156105c957335f818152600360205260409081902054905163db42144d60e01b815260048101929092526024820184905260448201526064016102ed565b335f90815260036020526040812080548492906105e790849061094d565b90915550506001600160a01b0383165f9081526003602052604081208054849290610613908490610960565b90915550506040518281526001600160a01b0384169033907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90602001610296565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b03811681146106a0575f5ffd5b919050565b5f5f604083850312156106b6575f5ffd5b6106bf8361068a565b946020939093013593505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561070a5761070a6106cd565b604052919050565b5f67ffffffffffffffff82111561072b5761072b6106cd565b5060051b60200190565b5f82601f830112610744575f5ffd5b813561075761075282610712565b6106e1565b8082825260208201915060208360051b860101925085831115610778575f5ffd5b602085015b8381101561079557803583526020928301920161077d565b5095945050505050565b5f5f604083850312156107b0575f5ffd5b823567ffffffffffffffff8111156107c6575f5ffd5b8301601f810185136107d6575f5ffd5b80356107e461075282610712565b8082825260208201915060208360051b850101925087831115610805575f5ffd5b6020840193505b8284101561082e5761081d8461068a565b82526020938401939091019061080c565b9450505050602083013567ffffffffffffffff81111561084c575f5ffd5b61085885828601610735565b9150509250929050565b5f5f5f60608486031215610874575f5ffd5b61087d8461068a565b925061088b6020850161068a565b929592945050506040919091013590565b5f602082840312156108ac575f5ffd5b6108b58261068a565b9392505050565b5f5f604083850312156108cd575f5ffd5b6108d68361068a565b91506108e46020840161068a565b90509250929050565b600181811c9082168061090157607f821691505b60208210810361091f57634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b818103818111156102a2576102a2610939565b808201808211156102a2576102a261093956fea264697066735822122052f2510fe498a98a316e559058454f6a46b71930b92d6384ed7f0ed8f1101c4e64736f6c634300081e0033")

// Method information struct
type MethodInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// Event information struct
type EventInfo struct {
	Name  string
	Topic Hash
}

// Error information struct
type ErrorInfo struct {
	Name      string
	Signature string
	Selector  HexData
}

// PackableMethod represents a method with packing capabilities
type PackableMethod struct {
	Name      string
	Signature string
	Selector  HexData
}

// PackableEvent represents an event with unpacking capabilities
type PackableEvent struct {
	Name  string
	Topic Hash
}

// PackableError represents an error with unpacking capabilities
type PackableError struct {
	Name      string
	Signature string
	Selector  HexData
}

// Pack encodes method arguments and returns the method selector + encoded arguments
func (pm *PackableMethod) Pack(args ...any) (HexData, error) {
	// Start with the 4-byte method selector
	selectorBytes := pm.Selector.Bytes()
	if len(selectorBytes) == 0 {
		return "", fmt.Errorf("invalid method selector")
	}

	// If no arguments, return just the selector
	if len(args) == 0 {
		return pm.Selector, nil
	}

	// Encode arguments using our ABI implementation
	var encodedArgs []byte
	for _, arg := range args {
		switch v := arg.(type) {
		case *big.Int:
			data, err := encodeUint256(v)
			if err != nil {
				return "", fmt.Errorf("encoding big.Int: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case Address:
			encodedArgs = append(encodedArgs, encodeAddress(v)...)
		case uint64, uint32, uint16, uint8:
			data, err := encodeUint256(v)
			if err != nil {
				return "", fmt.Errorf("encoding uint: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case int64, int32, int16, int8, int:
			data, err := encodeInt256(v)
			if err != nil {
				return "", fmt.Errorf("encoding int: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case bool:
			encodedArgs = append(encodedArgs, encodeBool(v)...)
		case string:
			encodedArgs = append(encodedArgs, encodeString(v)...)
		case []byte:
			encodedArgs = append(encodedArgs, encodeBytes(v)...)
		case [1]byte:
			encodedArgs = append(encodedArgs, encodeFixedBytes(v[:], 1)...)
		case [32]byte:
			encodedArgs = append(encodedArgs, encodeFixedBytes(v[:], 32)...)
		case []*big.Int:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []*big.Int array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case []uint64:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []uint64 array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		case []Address:
			elems := make([]interface{}, len(v))
			for i, elem := range v {
				elems[i] = elem
			}
			data, err := encodeArray(elems)
			if err != nil {
				return "", fmt.Errorf("encoding []Address array: %w", err)
			}
			encodedArgs = append(encodedArgs, data...)
		default:
			return "", fmt.Errorf("unsupported argument type: %T", v)
		}
	}

	// Combine selector + encoded arguments
	result := make([]byte, len(selectorBytes)+len(encodedArgs))
	copy(result, selectorBytes)
	copy(result[len(selectorBytes):], encodedArgs)

	return HexData("0x" + hex.EncodeToString(result)), nil
}

// MustPack encodes method arguments and panics on error
func (pm *PackableMethod) MustPack(args ...any) HexData {
	data, err := pm.Pack(args...)
	if err != nil {
		panic(fmt.Sprintf("Pack failed: %v", err))
	}
	return data
}

// Constructor information struct
type ConstructorInfo struct {
	Signature string
}

// Constructor returns constructor information
func Constructor() ConstructorInfo {
	return ConstructorInfo{
		Signature: "",
	}
}

// Event information
func GetApprovalEvent() EventInfo {
	return EventInfo{
		Name:  "Approval",
		Topic: HashFromHex("0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925"),
	}
}
func GetTransferEvent() EventInfo {
	return EventInfo{
		Name:  "Transfer",
		Topic: HashFromHex("0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"),
	}
}

// Error information
func GetInsufficientAllowanceError() ErrorInfo {
	return ErrorInfo{
		Name:      "InsufficientAllowance",
		Signature: "InsufficientAllowance(address,address,uint256,uint256)",
		Selector:  HexData("0x91beda24"),
	}
}
func GetInsufficientBalanceError() ErrorInfo {
	return ErrorInfo{
		Name:      "InsufficientBalance",
		Signature: "InsufficientBalance(address,uint256,uint256)",
		Selector:  HexData("0xdb42144d"),
	}
}

// Method registry provides access to packable contract methods
type MethodRegistry struct{}

// Event registry provides access to packable contract events
type EventRegistry struct{}

// Error registry provides access to packable contract errors
type ErrorRegistry struct{}

// AllowanceMethod returns a packable method for allowance
func (mr MethodRegistry) AllowanceMethod() *AllowanceMethod {
	return &AllowanceMethod{
		PackableMethod: PackableMethod{
			Name:      "allowance",
			Signature: "allowance(address,address)",
			Selector:  HexData("0xdd62ed3e"),
		},
	}
}

// ApproveMethod returns a packable method for approve
func (mr MethodRegistry) ApproveMethod() *ApproveMethod {
	return &ApproveMethod{
		PackableMethod: PackableMethod{
			Name:      "approve",
			Signature: "approve(address,uint256)",
			Selector:  HexData("0x095ea7b3"),
		},
	}
}

// BalanceOfMethod returns a packable method for balanceOf
func (mr MethodRegistry) BalanceOfMethod() *BalanceOfMethod {
	return &BalanceOfMethod{
		PackableMethod: PackableMethod{
			Name:      "balanceOf",
			Signature: "balanceOf(address)",
			Selector:  HexData("0x70a08231"),
		},
	}
}

// GetBalanceMethod returns a packable method for getBalance
func (mr MethodRegistry) GetBalanceMethod() *GetBalanceMethod {
	return &GetBalanceMethod{
		PackableMethod: PackableMethod{
			Name:      "getBalance",
			Signature: "getBalance()",
			Selector:  HexData("0x12065fe0"),
		},
	}
}

// MintMethod returns a packable method for mint
func (mr MethodRegistry) MintMethod() *MintMethod {
	return &MintMethod{
		PackableMethod: PackableMethod{
			Name:      "mint",
			Signature: "mint(address,uint256)",
			Selector:  HexData("0x40c10f19"),
		},
	}
}

// MultiTransferMethod returns a packable method for multiTransfer
func (mr MethodRegistry) MultiTransferMethod() *MultiTransferMethod {
	return &MultiTransferMethod{
		PackableMethod: PackableMethod{
			Name:      "multiTransfer",
			Signature: "multiTransfer(address[],uint256[])",
			Selector:  HexData("0x1e89d545"),
		},
	}
}

// NameMethod returns a packable method for name
func (mr MethodRegistry) NameMethod() *NameMethod {
	return &NameMethod{
		PackableMethod: PackableMethod{
			Name:      "name",
			Signature: "name()",
			Selector:  HexData("0x06fdde03"),
		},
	}
}

// SymbolMethod returns a packable method for symbol
func (mr MethodRegistry) SymbolMethod() *SymbolMethod {
	return &SymbolMethod{
		PackableMethod: PackableMethod{
			Name:      "symbol",
			Signature: "symbol()",
			Selector:  HexData("0x95d89b41"),
		},
	}
}

// TotalSupplyMethod returns a packable method for totalSupply
func (mr MethodRegistry) TotalSupplyMethod() *TotalSupplyMethod {
	return &TotalSupplyMethod{
		PackableMethod: PackableMethod{
			Name:      "totalSupply",
			Signature: "totalSupply()",
			Selector:  HexData("0x18160ddd"),
		},
	}
}

// TransferMethod returns a packable method for transfer
func (mr MethodRegistry) TransferMethod() *TransferMethod {
	return &TransferMethod{
		PackableMethod: PackableMethod{
			Name:      "transfer",
			Signature: "transfer(address,uint256)",
			Selector:  HexData("0xa9059cbb"),
		},
	}
}

// TransferFromMethod returns a packable method for transferFrom
func (mr MethodRegistry) TransferFromMethod() *TransferFromMethod {
	return &TransferFromMethod{
		PackableMethod: PackableMethod{
			Name:      "transferFrom",
			Signature: "transferFrom(address,address,uint256)",
			Selector:  HexData("0x23b872dd"),
		},
	}
}

// ApprovalEvent returns a packable event for Approval
func (er EventRegistry) ApprovalEvent() *ApprovalEventDecoder {
	return &ApprovalEventDecoder{
		PackableEvent: PackableEvent{
			Name:  "Approval",
			Topic: HashFromHex("0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925"),
		},
	}
}

// TransferEvent returns a packable event for Transfer
func (er EventRegistry) TransferEvent() *TransferEventDecoder {
	return &TransferEventDecoder{
		PackableEvent: PackableEvent{
			Name:  "Transfer",
			Topic: HashFromHex("0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"),
		},
	}
}

// InsufficientAllowanceError returns a packable error for InsufficientAllowance
func (er ErrorRegistry) InsufficientAllowanceError() *InsufficientAllowanceErrorDecoder {
	return &InsufficientAllowanceErrorDecoder{
		PackableError: PackableError{
			Name:      "InsufficientAllowance",
			Signature: "InsufficientAllowance(address,address,uint256,uint256)",
			Selector:  HexData("0x91beda24"),
		},
	}
}

// InsufficientBalanceError returns a packable error for InsufficientBalance
func (er ErrorRegistry) InsufficientBalanceError() *InsufficientBalanceErrorDecoder {
	return &InsufficientBalanceErrorDecoder{
		PackableError: PackableError{
			Name:      "InsufficientBalance",
			Signature: "InsufficientBalance(address,uint256,uint256)",
			Selector:  HexData("0xdb42144d"),
		},
	}
}

// Methods returns the method registry
func Methods() MethodRegistry {
	return MethodRegistry{}
}

// Events returns the event registry
func Events() EventRegistry {
	return EventRegistry{}
}

// Errors returns the error registry
func Errors() ErrorRegistry {
	return ErrorRegistry{}
}

// ApprovalEvent represents the Approval event
type ApprovalEvent struct {
	Owner   Address  `json:"owner"`
	Spender Address  `json:"spender"`
	Value   *big.Int `json:"value"`
}

// TransferEvent represents the Transfer event
type TransferEvent struct {
	From  Address  `json:"from"`
	To    Address  `json:"to"`
	Value *big.Int `json:"value"`
}

// InsufficientAllowanceError represents the InsufficientAllowance custom error
type InsufficientAllowanceError struct {
	Owner     Address  `json:"owner"`
	Spender   Address  `json:"spender"`
	Requested *big.Int `json:"requested"`
	Available *big.Int `json:"available"`
}

// InsufficientBalanceError represents the InsufficientBalance custom error
type InsufficientBalanceError struct {
	Account   Address  `json:"account"`
	Requested *big.Int `json:"requested"`
	Available *big.Int `json:"available"`
}

// AllowanceInput represents inputs for method allowance
type AllowanceInput struct {
	Field1 Address `json:"field1"`
	Field2 Address `json:"field2"`
}

// ApproveInput represents inputs for method approve
type ApproveInput struct {
	Spender Address  `json:"spender"`
	Value   *big.Int `json:"value"`
}

// MintInput represents inputs for method mint
type MintInput struct {
	To    Address  `json:"to"`
	Value *big.Int `json:"value"`
}

// MultiTransferInput represents inputs for method multiTransfer
type MultiTransferInput struct {
	Recipients []Address  `json:"recipients"`
	Amounts    []*big.Int `json:"amounts"`
}

// TransferInput represents inputs for method transfer
type TransferInput struct {
	To    Address  `json:"to"`
	Value *big.Int `json:"value"`
}

// TransferFromInput represents inputs for method transferFrom
type TransferFromInput struct {
	From  Address  `json:"from"`
	To    Address  `json:"to"`
	Value *big.Int `json:"value"`
}

// ConstructorInput represents constructor inputs
type ConstructorInput struct {
	Name        string   `json:"_name"`
	Symbol      string   `json:"_symbol"`
	TotalSupply *big.Int `json:"_totalsupply"`
}

// AllowanceMethod represents the allowance method with type-safe decode functionality
type AllowanceMethod struct {
	PackableMethod
}

// ApproveMethod represents the approve method with type-safe decode functionality
type ApproveMethod struct {
	PackableMethod
}

// BalanceOfMethod represents the balanceOf method with type-safe decode functionality
type BalanceOfMethod struct {
	PackableMethod
}

// GetBalanceMethod represents the getBalance method with type-safe decode functionality
type GetBalanceMethod struct {
	PackableMethod
}

// MintMethod represents the mint method with type-safe decode functionality
type MintMethod struct {
	PackableMethod
}

// MultiTransferMethod represents the multiTransfer method with type-safe decode functionality
type MultiTransferMethod struct {
	PackableMethod
}

// NameMethod represents the name method with type-safe decode functionality
type NameMethod struct {
	PackableMethod
}

// SymbolMethod represents the symbol method with type-safe decode functionality
type SymbolMethod struct {
	PackableMethod
}

// TotalSupplyMethod represents the totalSupply method with type-safe decode functionality
type TotalSupplyMethod struct {
	PackableMethod
}

// TransferMethod represents the transfer method with type-safe decode functionality
type TransferMethod struct {
	PackableMethod
}

// TransferFromMethod represents the transferFrom method with type-safe decode functionality
type TransferFromMethod struct {
	PackableMethod
}

// ApprovalEventDecoder represents the Approval event with type-safe decode functionality
type ApprovalEventDecoder struct {
	PackableEvent
}

// TransferEventDecoder represents the Transfer event with type-safe decode functionality
type TransferEventDecoder struct {
	PackableEvent
}

// InsufficientAllowanceErrorDecoder represents the InsufficientAllowance error with type-safe decode functionality
type InsufficientAllowanceErrorDecoder struct {
	PackableError
}

// InsufficientBalanceErrorDecoder represents the InsufficientBalance error with type-safe decode functionality
type InsufficientBalanceErrorDecoder struct {
	PackableError
}

// MustDecode decodes return values for allowance method
func (m *AllowanceMethod) MustDecode(data []byte) *big.Int {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return mustDecodeUint256(data[0:32])
}

// MustDecode decodes return values for approve method
func (m *ApproveMethod) MustDecode(data []byte) bool {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return decodeBool(data[0:32])
}

// MustDecode decodes return values for balanceOf method
func (m *BalanceOfMethod) MustDecode(data []byte) *big.Int {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return mustDecodeUint256(data[0:32])
}

// MustDecode decodes return values for getBalance method
func (m *GetBalanceMethod) MustDecode(data []byte) *big.Int {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return mustDecodeUint256(data[0:32])
}

// MustDecode decodes return values for name method
func (m *NameMethod) MustDecode(data []byte) string {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	result, _ := decodeString(data, 0)
	return result
}

// MustDecode decodes return values for symbol method
func (m *SymbolMethod) MustDecode(data []byte) string {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	result, _ := decodeString(data, 0)
	return result
}

// MustDecode decodes return values for totalSupply method
func (m *TotalSupplyMethod) MustDecode(data []byte) *big.Int {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return mustDecodeUint256(data[0:32])
}

// MustDecode decodes return values for transfer method
func (m *TransferMethod) MustDecode(data []byte) bool {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return decodeBool(data[0:32])
}

// MustDecode decodes return values for transferFrom method
func (m *TransferFromMethod) MustDecode(data []byte) bool {
	// Single return value
	if len(data) < 32 {
		panic("insufficient data for return value")
	}
	return decodeBool(data[0:32])
}

// MustDecode decodes log data for Approval event
func (e *ApprovalEventDecoder) MustDecode(data []byte) ApprovalEvent {
	// Decode event parameters (only non-indexed parameters are in data)
	result := ApprovalEvent{}
	offset := 0
	if len(data) < offset+32 {
		panic("insufficient data for event parameter value")
	}
	result.Value = mustDecodeUint256(data[offset : offset+32])
	offset += 32
	return result
}

// MustDecode decodes log data for Transfer event
func (e *TransferEventDecoder) MustDecode(data []byte) TransferEvent {
	// Decode event parameters (only non-indexed parameters are in data)
	result := TransferEvent{}
	offset := 0
	if len(data) < offset+32 {
		panic("insufficient data for event parameter value")
	}
	result.Value = mustDecodeUint256(data[offset : offset+32])
	offset += 32
	return result
}

// MustDecode decodes error data for InsufficientAllowance error
func (e *InsufficientAllowanceErrorDecoder) MustDecode(data []byte) InsufficientAllowanceError {
	// Skip the 4-byte selector
	if len(data) < 4 {
		panic("insufficient data for error selector")
	}
	errorData := data[4:]
	// Decode error parameters
	result := InsufficientAllowanceError{}
	offset := 0
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter owner")
	}
	result.Owner = decodeAddress(errorData[offset : offset+32])
	offset += 32
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter spender")
	}
	result.Spender = decodeAddress(errorData[offset : offset+32])
	offset += 32
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter requested")
	}
	result.Requested = mustDecodeUint256(errorData[offset : offset+32])
	offset += 32
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter available")
	}
	result.Available = mustDecodeUint256(errorData[offset : offset+32])
	offset += 32
	return result
}

// MustDecode decodes error data for InsufficientBalance error
func (e *InsufficientBalanceErrorDecoder) MustDecode(data []byte) InsufficientBalanceError {
	// Skip the 4-byte selector
	if len(data) < 4 {
		panic("insufficient data for error selector")
	}
	errorData := data[4:]
	// Decode error parameters
	result := InsufficientBalanceError{}
	offset := 0
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter account")
	}
	result.Account = decodeAddress(errorData[offset : offset+32])
	offset += 32
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter requested")
	}
	result.Requested = mustDecodeUint256(errorData[offset : offset+32])
	offset += 32
	if len(errorData) < offset+32 {
		panic("insufficient data for error parameter available")
	}
	result.Available = mustDecodeUint256(errorData[offset : offset+32])
	offset += 32
	return result
}
